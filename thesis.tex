\documentclass[
  digital,
  color,
  oneside,
  nosansbold,
  nocolorbold,
  lof,
  lot,
]{fithesis4}
\usepackage[resetfonts]{cmap}
\usepackage[T1,T2A]{fontenc}
\usepackage[
  main=english,
  english
]{babel}

\thesissetup{
    date        = \the\year/\the\month/\the\day,
    university  = mu,
    faculty     = fi,
    type        = bc,
    department  = Department of Computer Science,
    author      = Stanislav Zeman,
    gender      = m,
    advisor     = {RNDr. Martin Ukrop, Ph.D.},
    title       = {Designing a Comprehensive Course on Go},
    TeXtitle    = {Designing a Comprehensive Course on Go},
    keywords    = {go, golang, course, lectures, exercises, homework},
    TeXkeywords = {go, golang, course, lectures, exercises, homework},
    abstract    = {
      This thesis deals with designing and implementing a new course aimed at teaching the Go programming language. This work puts the Faculty of Informatics of Masaryk University into context, and its design reflects some of the shortcomings of local courses or their lack thereof. As such, the course goes beyond just the language fundamentals. The thesis implements multiple types of materials, primarily including lectures, exercises, and homework, while discussing the design decisions behind them. Multiple of the course lectures are based on an existing Go Course maintained under RedHat.
    },
    thanks      = {
      These are the acknowledgements for my thesis.
    },
    bib         = bibliography.bib,
    facultyLogo = fithesis-fi,
}
\usepackage{makeidx}
\makeindex
\usepackage{paralist}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{url}
\usepackage{markdown}
\usepackage{listings}
\lstset{
  basicstyle      = \ttfamily,
  identifierstyle = \color{black},
  keywordstyle    = \color{blue},
  keywordstyle    = {[2]\color{cyan}},
  keywordstyle    = {[3]\color{olive}},
  stringstyle     = \color{teal},
  commentstyle    = \itshape\color{magenta},
  breaklines      = true,
}
\usepackage{floatrow}
\floatsetup[table]{capposition=top}
\usepackage[babel]{csquotes}
\usepackage{hyperref}
\usepackage{cleveref}

\begin{document}

\chapter{Introduction}

Go is an aspiring programming language that has gained much traction in recent years. Initially introduced in 2009 and released in 2012, Go is characterized as a minimalist programming language prioritizing simplicity over integrating countless features, thereby avoiding bloating. Known mostly for its concurrency design, it is a language that enjoys extensive usage in the cloud-native environment.

\chapter{The Go programming language}

Go is an aspiring programming language that has gained much traction in recent years. Initially introduced in 2009 and released in 2012, Go is characterized as a minimalist programming language prioritizing simplicity over integrating countless features, thereby avoiding bloating. Known mostly for its concurrency design, it is a language that enjoys extensive usage in the cloud-native environment.

\section{Characteristics}

\section{Usage}

\chapter{The current state at FI MUNI}

As this thesis focuses on designing a course in the Faculty of Informatics Masaryk University (FI MUNI) context, it first maps the ground and explores the current state of related courses while describing both their benefits and shortcomings and providing references. It is worth noting that all of the information further described is my own observation as a bachelor's degree student studying the Programming and Application Development program (PVA). The observations are mostly concerned with practical applications.

\section{Up-to-date technologies and practical knowledge}

As it is often said, the faculty's goal is not to teach you specific technologies but to provide fundamental knowledge of informatics. I agree that this is valued in the long run as technologies evolve and change, but the fundamentals will always remain the same. However, I would like to oppose the idea somewhat.

If the faculty wants to act like we maintain profession-oriented study programs like "Programming and application development" (PVA)
\footnote{See \url{https://www.fi.muni.cz/admission/bc/programming-and-development.html.en}.}
or "Software Engineering" (SWE), 
\footnote{See \url{https://www.fi.muni.cz/admission/mgr/software-engineering.html.en}.}
we cannot simply stick to the fundamentals. 
Moreover, both of these study programs require attending an internship, each 480 and 400 hours long, respectively. The faculty should, at least to some extent, prepare the students for such endeavors. For example, students are pushed to attend an internship without ever having to connect an application to a database or without ever having to create an API \cref{web-dev}, which is quite absurd for a program that mentions application development in its name. Hence, students often have to settle for relatively limited internship positions even though they could go straight to working as juniors. The faculty should also not expect this knowledge to be given to the students during their internships, as it is often not the case.

\section{Related faculty courses}

This section describes related courses.

\subsection{Web development and markup languages} \label{web-dev}

Web development and markup languages
\footnote{See \url{https://is.muni.cz/predmet/fi/jaro2024/PB138?lang=en;setlang=en}.}
is a course originally called Modern Markup Languages and Their Applications that has been reworked from a solely markup language course, which dedicated all of its time to technologies like XML and HTML
\footnote{The course was last run in this form in the Spring of 2019. See \url{https://is.muni.cz/course/fi/spring2019/PB138} for more information.}.

The course nowadays includes programming and developing web applications using the Typescript programming language. The scope of the subject is rather large, as it has to cover all of the topics from designing a database scheme and implementing a persistence layer and API to creating single-page applications using React.

This is the only mandatory course for the PVA program that currently addresses most of the program's shortcomings and teaches the knowledge mostly required in practice.

\subsection{Programming in Rust}

This Go course is somewhat inspired by an existing course taught at FI MUNI called Programming in Rust 
\footnote{See \url{https://is.muni.cz/predmet/fi/podzim2023/PV281?lang=en} for more information.}
under the code PV281. I first attended the course in the Autumn of 2022 and later joined in on its third run in the Autumn of 2023 as a seminar tutor.

From my personal experience, this course has been a great source of knowledge, especially for me as a second-year student, that I could mostly apply to practice. Besides obviously teaching Rust, the course went beyond just the programming language as it taught topics like software architecture design, introduced web development and databases basics, and heavily used Docker throughout its latter seminars.

As great of an experience as it was, the course certainly had its shortcomings. Docker, for example, was not properly introduced even though it was never even mentioned in its prerequisites. Some Docker knowledge was, therefore, implicitly expected. To this day, only a single course \cref{code-quality-and-management} delves into the topics of containerization with practical applications.

Because of the scope of the course, it did not properly delve into the depth of the Rust programming language. One topic that is worth mentioning is macros, which the course lacked and are leveraged by the language quite heavily. Macros were only introduced as part of a bonus lecture that, in the end, did not occur. Therefore, it appeared to be an afterthought.

\subsection{Basic Code Quality and Management} \label{code-quality-and-management}

Although this course
\footnote{See \url{https://is.muni.cz/predmet/fi/jaro2024/PB176?lang=en}.}
delves into the problematics of Docker, it does so in a way that makes it voluntary. Unfortunately, to my knowledge, 
\footnote{This information is based on the course run of Spring 2024} the course explores Docker in its final lectures and does not dedicate proper space to this technology. Moreover, only the last fourth homework focuses on the Docker technology and requires three completed homework for the course completion. Consequently, the Docker homework becomes optional if students have completed the previous four assignments, so they are not required to do it.

\section{RedHat Go Course}

During the Autumn semester of 2023, a new first trial run for the Go programming language course was planned under the course Domain-specific development
\footnote{See \url{https://is.muni.cz/predmet/fi/podzim2023/PB173?lang=en}.}.
The course was organized by Martin Ukrop and led by Pavel Tišnovský and Ivan Nečas, both of whom maintain an existing Go Course \cite{redhat-go-course} under Redhat. At that time, I had been studying Go for several months, and as I was deeply interested and dedicated to mastering it, I decided to join in on the efforts.

The RedHat Go Course was originally designed to cover the language fundamentals, and thanks to Go being a minimalistic language, teaching it only took half of the semester. The second half was lecture-free, and the students were left to implement their projects. A subsequent project defense was organized for the last week of the semester where students provided a description and a demonstration of the projects. The projects were also submitted for review, which we provided two weeks after the defense.

\section{Motivation for extending the course}

The course was short and limited in scope, so it felt like it missed a couple of opportunities. To name a few, it did not cover any interesting technologies, the basics of API design, or the integration and access to a database. As a result, we have decided to expand the scope of the course with additional materials and rework the existing ones.

\subsection{Questionnaire}

After the successful end of the first run, we issued a questionnaire to gather student feedback for things that could be improved and incorporated into the new course. We gathered feedback from nine students out of the nineteen who finished the course. The course originally started with twenty attendees.

One of the greatest shortcomings I suspected and later confirmed by the questionnaire was a lack of programming exercises. The final project was the only output we required from the students. Thanks to it being final, students had no motivation to put in any extra effort throughout the semester.

The students unequivocally agreed that additional activities would be welcome. However, they generally opposed the idea of dedicated seminars as the Go language was too simple and preferred homework exercises. Some of the excerpts
\footnote{These excerpts were translated from Czech/Slovak languages.}
to the related question: \\

\subsubsection{Additional exercises}

\noindent
Q: \textit{
"Would you welcome dedicated seminars or additional assignments with feedback to accompany the lectures? If so, which of these two options would you prefer and why?"} \\

\noindent
A1: \textit{"For me, assignments are more important; seminars in programming subjects generally don't make much sense to me."} \\

\noindent
A2: \textit{"Definitely homework. I don't think seminars and working with a tutor are necessary. Homework can be solved anytime; they are not time-bound or tied to a specific time."} \\

\noindent
A3: \textit{"Seminars aren't very necessary; I understood everything well from the lectures and could immediately apply it. Homework might help with revision. Also, the project was practically a homework assignment."} \\

\subsubsection{Sneekpeek to the new course outline}

\noindent
When presented with an older version of the overview
\footnote{The original overview included an additional Event-driven programming lecture. It was discarded as I deemed it not as important. Instead, the Observability lecture further described in \cref{lecture-observability} was preferred.}
showcased in the \cref{design-overview}. The students generally welcomed the changes: \\

\noindent
Q: \textit{
"Would you welcome dedicated seminars or additional assignments with feedback to accompany the lectures? If so, which of these two options would you prefer and why?"} \\

\noindent
A1: \textit{"The second half sounds really great. Too bad it wasn't there this year; it's exactly what would greatly improve the course."} \\

\noindent
A2: \textit{"It looks great. I hope that the materials for the next run will be available for graduates of this course, too. I would love to learn something new."} \\

\noindent
A3: \textit{"The content looks great; it's good that there's room for more interesting stuff."} \\

\noindent
However, some concerns were raised by the new material additions: \\

\noindent
A4: \textit{"For me, the question is whether topics 7-11\footnote{This references the same lectures as described by the overview in \cref{design-overview} with the addition of the discarded Event-driven programming lecture.} should belong to the Go programming subject or a separate half-course. What initial knowledge do you expect students to have in these topics? Each of these topics seems quite broad to me, so you would have to go superficially for students who haven't encountered the topic yet or assume some basic knowledge. Certainly, the initial questionnaire for students will help you with this, but I would expect that without prerequisites, there will always be students who are completely unfamiliar with the topic."} \\

\noindent
A5: \textit{"Will the conclusion still involve a project? Won't it be too much in conjunction with assignments?"} \\

\noindent
These concerns are further reflected in the course design described in \cref{course-design}. \\

\subsubsection{General feedback}

\noindent
Some of the additional general feedback provided on the course: \\

\noindent
Q: \textit{"Are there any concepts or specific aspects of Go that you feel you still don't fully understand even after completing the course?"} \\

\noindent
A1: \textit{"During project creation, I struggled with structuring the project and how to design it. Also, I found it challenging to create packages sensibly and avoid cyclic imports."} \\

\noindent
A2: \textit{"Perhaps goroutines, but I don't think we focused on them too much."} \\

\noindent
A3: \textit{"Perhaps delve more into packages."} \\

\noindent
A4: \textit{"Slices and arrays, although it might be because I didn't work with them much in my project."} \\

\noindent
Q: \textit{"Did you lack any knowledge during project implementation that the course didn't cover adequately?"}

\noindent
A1: \textit{"I didn't understand how to run Docker and how to use it."} \\

\noindent
A2: \textit{"Perhaps how to set up a repository and how to structure a larger project. It's nothing that couldn't be looked up, but it would be nice to have it included in the course."} \\

\noindent
A3: \textit{"Slices and arrays, although it might be because I didn't work with them much in my project."} \\

\noindent
A4: \textit{"If I had paid more attention (or if greater attention had been demanded from me, for example through exercises or assignments) during the semester, I wouldn't have had to rush to catch up on everything during project work."} \\

\noindent
These comments are also reflected throughout the design \cref{course-design}.

\subsection{Interest}

The first run of the RedHat Go Course was Go's first occurrence at our faculty. There is certainly a great interest in the Go programming language. I judge this by having personal conversations with peers and other tutors and by the spike \footnote{At one point, over one hundred students enrolled for the course.}
in course enrollments before the semester that I perceived. However, it must be noted that the course under which the Go Course ran shared it with two additional seminars, so this fact may be inconclusive.

\chapter{The course design}\label{course-design}

This chapter gives high-level insight into the course design and the reasoning behind the decisions taken. Detailed explanations about particular lectures, exercises, and homework are given in the fourth chapter.

\section{Elementary information}

The course primarily focuses on teaching the Go programming language. However, its goal is not only to teach the fundamentals of Go, but the course also focuses on equipping its students with the knowledge often required in practice.

The course builds upon the foundations of an already existing Go Course maintained under RedHat\cite{redhat-go-course}. This course already implemented numerous lectures, which were mainly reworked and restructured.

The newly created course is intended to be taught throughout the span of twelve weeks. The first eleven weeks are regular lessons, and the last week is reserved for consultation and/or as a potential substitute class.

\subsection{Licensing}

The original course is open-sourced under the Creative Commons Attribution-ShareAlike (CC BY-SA 4.0 Deed) license
\footnote{See \url{https://creativecommons.org/licenses/by-sa/4.0/} for license details.}
, and as it is a share-alike license, the new course had to respect it. There was an option to migrate to the GPLv3 license
\footnote{See \url{https://www.gnu.org/licenses/gpl-3.0.en.html} for license details.}
, which is compatible, but in the end, the CC license was preferred.

The original idea was to keep the new course open-sourced either way, so reusing and adapting the existing course was not a deterrent. The motivation behind this was to keep the course in the public space. Anyone who would like to remix or reuse the course would be free to do so. There is no reason to keep anyone from using any of its materials, even for those with commercial intentions.

\section{Overview}\label{design-overview}

The course materials are structurally split into three major categories: lectures, exercises, and homework, to be specific, each with a dedicated git repository. All of these categories are inspected in the following subsections. The last subsection of this chapter briefly talks about the final projects.

\subsection{Lectures}

The lecture slides are indubitably the most vital type of material. 

The first six lessons are adaptations of the original RedHat Go Course slides, which underwent major changes and restructuring. The changes were made to make the taught topics more cohesive and easier to follow, as some of the code samples were unnecessarily long or complex. Several lessons, specifically those on REST API and Concurrency, presented outdated principles that warranted updating. Multiple lectures, such as Math \& Go or Python \& Go, were removed altogether as I did not deem them important.

The last five lectures are completely new and extend the course with numerous technologies and third-party libraries. The original course focused solely on using the standard library. Some of the parts of the standard library, notably the HTTP web router, are generally not leveraged in practice. The new lectures focus more on practical usage; therefore, they are not limited in this way.

\subsubsection{Tooling}

I considered multiple tools for creating the lecture slides. It certainly had to be a markdown-oriented technology for multiple reasons. A plain-text solution was a necessity as all materials are versioned using git. This, in turn, eases collaboration with potential open-source contributors, which can further extend the course or fix any existing mistakes.

The original RedHat Go course used the Go Present tool
\footnote{See \url{https://pkg.go.dev/golang.org/x/tools/present} for more information.}.
This solution, created by the Go team, implements an exceptional feature: it can run the Go code in your slides and immediately present the output. For this reason, I decided to continue using it for the new lectures as any other markdown-styled solution did not offer any similar viable alternative.

I also considered Marp
\footnote{See \url{https://marp.app} for more information.}
as the runner-up. This tool is used throughout the Rust course previously mentioned in the second chapter. Compared to the Go Present tool, the main benefits include much better formatting capabilities, the possibility of exporting slides to multiple data formats like PDF or HTML, and a more straightforward syntax.

\subsection{Exercises}

The exercises are designed to be complementary assignments to lectures. The general feedback on the first course run, as discussed in the second chapter, was a lack of hands-on experience. These exercises were designed to compensate for that. They are, by no means, an equivalent substitute for traditional standard seminars. The students are expected to spend only up to thirty minutes solving them.

Each lecture is paired with a single exercise that can, in some cases, be split into up to two tasks. Both of these, in some way, relate to the topics covered in the lecture.

The exercises are not intended to be reviewed or evaluated in any way. However, they can provide useful on-site insight into the student's understanding of the covered topic, which can be reflected later. These exercises should also serve as the ground for answering potential follow-up questions.

\subsection{Homework}

The homework exercises are a form of individual work. Their goal is to prepare students for their final projects. The homework tasks depend on each other and demonstrate building an application from the ground up.

Starting from the third week, the assignments are published with a fourteen-day deadline followed by a seven-day review period. The review period is designed to give students feedback that they will later incorporate into their solutions.

Contrary to lecture exercises, homework exercises are intended to be reviewed and graded. In the end, they should make up half of the final grade.

\subsection{Projects}

The projects are the final part of the course and make up the second half of the final grade. The projects are estimated to take fifty to sixty hours for each student. The size of the projects should approximately match that estimation.

As part of a bonus lecture \cref{lecture-projects}, the students are presented with a set of technologies or libraries they can leverage in their project implementations. This lecture subordinately serves as a form of motivation.

The general incentive is to make students come up with their own projects. Therefore, no "official" project assignments will be published. This was deeply considered as it may demotivate some students in the final part of the semester. However, I believe that the exploratory bonus lecture is sufficient for driving the students' projects even without predefined assignments.

No matter the choice of project, all of them are finished with a short defense during the examination period. These defenses can be organized either physically or online. Students are expected to give a short presentation and a demonstration. Students should also cover used technologies and libraries and briefly describe their experiences and struggles.

There are multiple means of completing the project, each offering a different set of advantages and disadvantages. The course is designed not to be overly restrictive, therefore giving flexibility of choice for the projects.

The project assignment can be fulfilled in three ways:
\begin{itemize}
 \item Implementing a team project.
 \item Implementing a solo project.
 \item Creating an open-source contribution.
\end{itemize}

\subsubsection{Team projects}

The team projects required coordination between the team members; therefore, it simulates practical collaboration the most. However, it restricts students as they have to agree on a single project assignment. 

The recommended number of team members is up to four students. The size of the projects should be linearly scaled with the number of team members. It is strongly advised not to be exceeded. Any higher number may negatively affect the teams' performance as it brings an additional overhead.

When evaluating projects, it should be verified that the work was roughly evenly distributed between the students. As often happens, some students leave most of the work for their team members and only join in on minor tasks, if at all. Such lack of activity should be reflected in the student's evaluation.

It should also be noted that sometimes, a student implements most of the project assignment independently without giving the rest of the team a chance to contribute appropriately. Differentiation between the two cases is merely impossible. The only way is to consult the team members directly, and even then, the active students tend not to report on and abandon their peers.

\subsubsection{Solo projects}

The solo projects give the most flexibility. Students can implement their own assignments without consulting or cooperating with other team members. This, for example, allows them to implement a project they have long thought about but did not find enough time for its realization.

On the other hand, the lack of interaction with peers is also the biggest disadvantage. The goal of these projects should, at least to some extent, be to get students familiar with real-life software project collaboration. Such projects are hardly implemented by solo developers.

Students generally perceive this way as the path of least resistance, so it should be expected that the majority of projects will be of this kind.

\subsubsection{Open-source contributions}

The open-source contributions are rather experimental. The main motivation behind this variant is to allow students to get involved in the open-source community, give them a guiding hand, and provide feedback for their first steps. 

This path presents several challenges to the students. First, the students must find open-source projects to contribute to. Secondly, they must engage, review current issues, and participate in the discussion and codebase. Lastly, they must implement the changes and get them reviewed and merged.

The pull or merge requests do not have to be merged at the time of the defense, as the tutors cannot guarantee the maintainers' activity. This can be tackled by providing projects maintained by tutors or their colleagues. However, such appropriate "good-first" projects that are simultaneously maintained by the tutors often hardly exist.

The contributions can be split up into multiple pull or merge requests, even to different projects. Therefore, opening a larger pull request and opening multiple smaller ones are both acceptable variants.

The size expectations for the open-source contributions are much lower than those for its project alternatives. Upon its evaluation, the process of searching for an open-source project to contribute to and further involvement in the codebase is considered.

It should be noted that contributing to projects with low activity or without active maintainers should be avoided.

In my opinion, our faculty does not promote open-source collaboration enough. The faculty's lack of permanent open-source-oriented courses exploring open-source workflow and etiquette can further support this statement. It is worth noting that some efforts to introduce such courses have been made in collaboration with industrial partners in the past few years.

\section{Limitations}

\subsection{Covered Topics}

This subsection describes some possible inefficiencies that were later perceived but not incorporated into the course because of the lack of time or space.

\subsubsection{Auth}

The course does not cover authorization or authentication in any way. It is up to debate if the course should cover this topic and, if so, to what extent. I believe that education in this regard, especially with practical application, is insufficient at our faculty. A dedicated course tackling topics like JWT, Cookies, and OAuth2 and their usage should exist instead.

\subsubsection{APIs}

The course currently covers designing and implementing REST APIs. This is still the standard for most service communication. However, during the past decade, multiple other approaches emerged that are often incorporated into systems in practice, notably gRPC and GraphQL. \\

gRPC is an implementation of the Remote Procedure Call (RPC) protocol by Google (g). It is often used for server-to-server communication as it provides type safety, lowers latency thanks to transmitting binary data using its custom format, and performs client/server code generation. \\

GraphQL (GQL) is a query language that was created at Facebook. It is built on top of standard REST API. GQL is often used for APIs that operate with complicated structured data. It removes the necessity to implement numerous endpoints and instead allows GQL queries to be sent to a single endpoint that parses the query and responds only to data specified in the query. Clients can fetch all required data using a single request. This way, the process saves time and network bandwidth.

\subsubsection{DevOps/Ops overlap}

Some of the lectures, namely Infrastructure and Observability, overlap with the DevOps/Ops field. Although the lectures provide Go examples and try to apply the general knowledge to Go, these topics are not Go specific and could be extracted to an additional course in the future. This would free up space for other topics, such as those previously mentioned.

\chapter{The course content}

The content is described in the same order as it is presented to students throughout the semester.

\section{Lecture 00: The course}

This lecture is designed solely to provide elementary information about the course, such as its requirements and outline.

\section{Lecture 01: Introduction}

\subsubsection{Outline}

\begin{itemize}
    \item Introduction to Go
    \begin{itemize}
        \item Origins
        \item Key characteristics \& comparisons
        \item Motivation
    \end{itemize}
    \item IDEs \& editors
    \item Installing Go
    \item Go
    \begin{itemize}
        \item Go executable
        \item Modules
        \item Packages
        \item Hello world
    \end{itemize}
\end{itemize}

\subsubsection{Content}

\subsection{Exercise 01}

\section{Lecture 02: Fundamentals \#1}

\subsubsection{Outline}

\begin{itemize}
    \item Types
    \item Variables
    \item Control flow
    \item Functions
    \item User-defined data types
    \item Pointers
\end{itemize}

\subsubsection{Content}

\subsection{Exercise 02}

\section{Lecture 03: Fundamentals \#2}

\subsubsection{Outline}

\begin{itemize}
    \item Interfaces
    \item Errors
    \item Arrays
    \item Slices
    \item Maps
    \item Range
\end{itemize}

\subsubsection{Content}

\subsection{Exercise 03}

\section{Lecture 04: Concurrency \& Parallelism}

\subsubsection{Outline}

\begin{itemize}
    \item Goroutines
    \item Runtime
    \item Channels
    \item Select
    \item Packages
\end{itemize}

\subsubsection{Content}

\begin{figure}[H]
    \centering
    \includegraphics[width=12cm]{figures/concurrency-parallelism.png}
    \caption{Differences between concurrency and parallelism}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=12cm]{figures/scheduling.png}
    \caption{Possible runtime state.}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=12cm]{figures/buffered-full.png}
    \caption{Interaction between two goroutines interaction via a buffered channel.}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=12cm]{figures/fanin.png}
    \caption{Diagram of the fan-in pattern.}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=12cm]{figures/fanout.png}
    \caption{Diagram of the fan-out pattern.}
\end{figure}

\subsection{Exercise 04}

\section{Lecture 05: Advanced \#1}

\subsubsection{Outline}

\begin{itemize}
    \item Generics
    \item Packages
    \item Testing
\end{itemize}

\subsubsection{Content}

\begin{figure}[H]
    \centering
    \includegraphics[width=12cm]{figures/pyramids.png}
    \caption{Testing models.}
\end{figure}

\subsection{Exercise 05}

\section{Homework 01}

\section{Lecture 06: Advanced \#2}

\subsubsection{Outline}

\begin{itemize}
    \item Benchmarks
    \item Profiling
    \item Optimizations
    \begin{itemize}
        \item References \& Values
        \item Maps
        \item Slices
        \item Loops
        \item Strings
    \end{itemize}
    \item CGo
    \item Unsafe
    \item Reflection
\end{itemize}

\subsubsection{Content}

\subsection{Exercise 06}

\section{Lecture 07: REST APIs}

\subsubsection{Outline}

\begin{itemize}
    \item JSON
    \item HTTP
    \item REST API
    \item Go \& HTTP
    \begin{itemize}
        \item Standard library
        \item Third-party libraries
        \item Testing webservers
    \end{itemize}
    \item OpenAPI
    \item Templating
\end{itemize}

\subsubsection{Content}

\subsection{Exercise 07}

\section{Homework 02}

\section{Lecture 08}

\subsubsection{Outline}

\begin{itemize}
    \item Containers
    \item Docker
    \begin{itemize}
        \item Desktop
        \item Hub
        \item Build
        \item Compose
    \end{itemize}
    \item Podman
    \item Testcontainers
    \item Kubernetes
\end{itemize}

\subsubsection{Content}

\subsection{Exercise 08: Containers}

\section{Lecture 09: Databases}

\subsubsection{Outline}

\begin{itemize}
    \item SQL
    \item RDBMSs
    \item Database migrations
    \item Go \& SQL
    \begin{itemize}
        \item sql
        \item sqlx
        \item sqlc
        \item GORM
    \end{itemize}
\end{itemize}

\subsubsection{Content}

\subsection{Exercise 09}

\section{Homework 03}

\section{Lecture 10: Infrastructure}

The motivation behind this lecture is to give students an insight into the CI/CD process and how this practice can be applied in the context of Go projects. The second goal is to give students a basic knowledge of how such projects can be deployed and maintained.

The students are expected to understand basic software engineering practices and elementary networking.

\subsubsection{Outline}

\begin{itemize}
    \item Linters
    \item CI/CD
    \begin{itemize}
        \item GitLab CI/CD
        \item GitHub Actions
    \end{itemize}
    \item Infrastructure
    \item Cloud
    \begin{itemize}
        \item GCP
    \end{itemize}
\end{itemize}

\subsubsection{Content}

The first section covers linters and expands on the knowledge acquired in the introductory lesson, where the built-in go-vet linter was introduced. Most of this section is dedicated to the golangci-lint tool, a linter aggregator incorporated in many projects and is the most complex tool today. Together with formatters, these tools are necessary in the continuous integration process introduced in the following section. \\

The second section introduces the CI/CD process. The primary goal of this section is to provide students with the knowledge to implement the CI/CD pipeline using both GitLab CI/CD and GitHub Actions.

As the faculty operates a self-hosted GitLab instance, almost all of the git-related work is done using GitLab. Consequently, most students do not interact with GitHub throughout their studies. The secondary goal of this chapter is to familiarize students with GitHub so they can join the open-source community, as most open-source software is developed on the GitHub platform. \\

\begin{figure}[H]
    \centering
    \includegraphics[width=12cm]{figures/cicd.png}
    \caption{CI/CD pipeline.}
\end{figure}

The third section gives an introduction to infrastructure design. Introduces basic concepts such as proxying, load balancing, and application scaling. Two related technologies are introduced to leverage these concepts, namely Traefik Proxy and Caddy. This section aims to give students a basic understanding of how to provision basic infrastructure and tackle basic infrastructure design problems such as fault tolerance, scaling, or encryption.

\begin{figure}[H]
    \centering
    \includegraphics[width=12cm]{figures/infrastructure.png}
    \caption{One of the infrastructure example diagrams.}
\end{figure}

The last section introduces all major cloud providers (Amazon, Microsoft, and Google) and further develops into Google Cloud Platform (GCP). As Google offers free credits thanks to the faculty program, it is a great opportunity for students to get their hands on operating cloud infrastructure. A set of basic services that GCP offers are introduced so students can leverage these in their follow-up projects.

\subsection{Exercise 10}

The exercise comprises two tasks. The second task is more of a demo in which the tutor will guide the students through the GCP Console.

As students generally have a basic understanding of CI, thanks to their previous experiences, it is not practiced at the seminar. Instead, the seminar time is given to the GCP. The goal of the demo/exercise is to get students familiar with the GCP so they can provision their own infrastructure.

Tasks:
\begin{itemize}
    \item The first task involves setting up a Caddy server instance as a reverse proxy/load balancing multiple ping-pong service instances.
    \item The second task involves setting up an automatic build and deployment using Cloud Run, provisioning a Compute Engine virtual machine and a Cloud SQL SQL server that can later be used for the student's projects.
\end{itemize}
    
\section{Lecture 11: Observability}\label{lecture-observability}

This lecture delves into the topic of observability. The lecture covers all major types of telemetry signals, namely metrics, logs, and traces. Each signal is briefly introduced, after which specific state-of-the-art \footnote{Many alternative technologies to the ones provided exist. The selection was made based on a general prevalence and on the fact that they are open-source and implemented in Go.}
technologies are introduced. In the last part, the OpenTelemetry project is introduced.

Following the lecture, students should be able to set up the introduced technologies, instrument their applications with basic telemetry, and monitor their applications' health. No previous knowledge regarding observability is required.

\subsubsection{Outline}

\begin{itemize}
    \item Health
    \item Metrics
    \begin{itemize}
        \item Prometheus
        \item Grafana
    \end{itemize}
    \item Logs
    \begin{itemize}
        \item Loggers
        \item Loki
    \end{itemize}
    \item Traces
    \begin{itemize}
        \item Jaeger
    \end{itemize}
    \item OpenTelemetry
\end{itemize}

\subsubsection{Content}

The lecture starts off with an introduction to concepts such as health and heartbeat and shows how to export application status. \\

The next section covers the first of the three major signal - metrics. A brief explanation with multiple metric examples is given. The spotlight is then transferred to the Prometheus project.

Prometheus 
\footnote{See \url{https://https://prometheus.io} for more information.}
is undeniably the leading project that revolves around retrieving, storing, and evaluating metrics. The Prometheus format is supported by multiple third-party tools. The section introduces the Prometheus format and the various metric types it supports.

Lastly, this section introduces Grafana 
\footnote{See \url{https://grafana.com/grafana/} for more information.}
as the project of choice for visualizing metrics. The slides refer to the Granafa sandbox
\footnote{See \url{https://play.grafana.org/d/000000012/grafana-play-home} for more information.}
that can be explored during the lecture shortly. \\

The second signal to cover is logs. This section puts logs into context and introduces additional structured logging libraries that offer additional features and focus more on performance compared to standard library packages.
The technology of choice for logs is Loki. Created by the Grafana Labs, it is a log aggregation system heavily inspired by Prometheus. The lecture covers the basic setup and summarizes possible clients and agents that can be used to retrieve the logs. \\

The final presented signal is traces. As traces are the most complex of all the mentioned telemetry types, a more thorough introduction is given. Then, a transition to Jager is made.

Like with Loki, the slides introduce Jaegers architecture and core concepts. As Jaeger dropped support for all of its previous clients and now only supports OpenTelemetry API and SDK, the instrumentation part is left out and shown in the following section, where OpenTelemetry is explored in-depth. \\

The OpenTelemetry 
\footnote{See \url{https://opentelemetry.io} for more information.}
project is an initiative that has gained much traction in recent years. Backed by the Cloud Native Computing Foundation (CNCF)
\footnote{See \url{https://www.cncf.io} for more information.},
it is currently the leading project in defining telemetry standards. As of today, all major cloud providers support it. The last section gives insight into the OpenTelemetry Collector and its architecture, explains how OpenTelemetry works, and how applications can be instrumented using its Go API and SDK.

\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{figures/opentelemetry-architecture.png}
    \caption{OpenTelemetry Architecture inspired by the documentation diagram.}
\end{figure}

\subsection{Exercise 11}

\section{Homework 04}

\section{Bonus Lecture: Projects} \label{lecture-projects}

The motivation for this lecture is to provide students with an overview of state-of-the-art libraries that can be used in the final Go projects. The technologies are split up into multiple sections depending on their use case.

\subsubsection{Outline}

\begin{itemize}
    \item CLI
    \item TUI
    \item Desktop
    \item Web
    \item Open-source
\end{itemize}

\subsubsection{Content}

The Command Line Interface (CLI) section provides basic information about the most frequently used libraries to implement command-line applications. These libraries include the Cobra \cite{spf13-cobra} and the CLI \cite{urfave-cli}.

The lecture continues by introducing the Bubbletea \cite{charmbracelet-bubbletea} framework and its ecosystem for creating Terminal User Interface (TUI) applications.

The third section introduces possible libraries for implementing desktop applications. The first framework it introduces is Wails \cite{wailsapp-wails}, an alternative to JavaScript Electron \cite{electron-electron}, or Rust Tauri \cite{tauri-apps-tauri} frameworks. The second mentioned library is Fyne \cite{fyne-io-fyne}, which, also from desktop environments, supports the iOS and Android mobile platforms.

The web sections mentions the possibility of creating a web application with a combination of Go backend and an optional frontend technology. The HTMX HTML extension \cite{bigskysoftware-htmx} is mentioned as an alternative to traditional single-page applications (SPAs).

The lecture ends with giving multiple links to resources related to open-source development or possible Go projects.

\chapter{Conclusion}

\printbibliography[heading=bibintoc]

\appendix
\chapter{Course materials}

All course materials are maintained under the \href{https://github.com/course-go}{course-go} GitHub organization. To preserve the current state of the materials, all relevant repositories were exported and compressed into an attachment to this thesis. Each top-level directory in the attached archive maps to a GitHub repository. The directories contain versions of materials that existed when submitting this thesis and are most likely out-of-date as you read this text. Inspect the respective GitHub repositories if you want to view the updated version.

The GitHub repositories for respective directories can be found under the following URLs:
\begin{itemize}
    \item \href{https://github.com/course-go/lectures}{lectures}
    \item \href{https://github.com/course-go/exercises}{exercises}
    \item \href{https://github.com/course-go/homework}{homework}
    \item \href{https://github.com/course-go/code}{code}
    \item \href{https://github.com/course-go/course}{course}
    \item \href{https://github.com/course-go/ping-pong}{ping-pong}
\end{itemize}

\section{lectures}

The lectures directory contains all slides and their respective assets (images, code samples, videos, etc.). The supplied README in the directory guides you on how to run the slides.

\section{exercises}

The exercises directory contains all exercises with assignments and related code. Each exercise is in a separate directory containing a README specifying the assignment.

\section{homework}

The homework directory contains all homework assignments. Each homework assignment is located in its respective directory. The assignments are given in the form of a README.

\section{code}

The code directory contains source code that either implements solutions to some of the exercises or implements some form of functionality used throughout the exercises.
\section{course}

The course directory contains information that serves as the starting point when people want to learn more about the course.
\section{ping-pong}

The ping-pong directory contains a simple REST API project used for teaching deployments and their automation. It is split up from the code project as it simplifies the deployments.

\chapter{Catalog specification}

This chapter specifies the common catalog used at Masaryk University.

\subsubsection{Extent and Intensity}

The following expression notes the intensity of lectures, seminars, and homework, plus the type of completion, respectively.

(2/0/1) + 1 (colloquium)

\subsubsection{Prerequisities}

No hard requirements are enforced. However, students must possess programming fundamentals (IB111)\footnote{ \url{https://is.muni.cz/predmet/fi/podzim2023/IB111?lang=en}.} and a basic understanding of networking (PB156)\footnote{\url{https://is.muni.cz/predmet/fi/jaro2012/PB156?lang=en}.} and virtualization (PB152)\footnote{\url{https://is.muni.cz/predmet/fi/jaro2020/PB152?lang=en}.} to the extent of referenced courses.

\subsubsection{Enrolment limitations}

The course is intended to be run with up to 20 students. It can later be scaled to a higher number, but currently, the intent is to test the new course in practice and interact more with students, which does not scale well and would require opening a second seminar.

\subsubsection{Course objectives}

Students will understand the fundamentals of the Go programming language and its common uses in practice. They will acquire the required knowledge for entry-level Go developer positions while writing idiomatic Go code, and they will be capable of applying this knowledge to real-life projects.

\subsubsection{Learning outcomes}

Students will be able to:
\begin{itemize}
    \item Write idiomatic Go code.
    \item Understand the Go concurrency model.
    \item Inspect and optimize Go applications.
    \item Develop REST API services.
    \item Containerize and deploy their applications.
    \item Implement persistence leveraging SQL databases.
    \item Instrument applications with various types of telemetry.
\end{itemize}

\subsubsection{Syllabus}

\begin{enumerate}
    \item Introduction: (Introduction to Go, IDEs and editors, Installing Go, Running Go)
    \item Fundamentals \#1: (Packages \& Visibility, Variables, Data types, Control flow, Functions, Pointers, User-defined data types)
    \item Fundamentals \#2: (Interfaces, Errors, Arrays, Slices, Maps, Range)
    \item Concurrency \& parallelism: (Goroutines, Runtime, Channels, Select, Related packages)
    \item Advanced \#1: (Generics, Packages, Testing)
    \item Advanced \#2: (Benchmarks, Optimizations, CGo, Unsafe \& Reflect)
    \item REST APIs: (JSON, HTTP, REST API, HTTP package, Routers \& Web frameworks, OpenAPI, Templating)
    \item Containers: (Containerization, Docker, Kubernetes)
    \item Databases: (SQL, RDBMSs, Migrations, SQL, sqlx, sqlc, GORM)
    \item Infrastructure: (CI/CD, Infrastructure, Google Cloud Platform)
    \item Observability: (Health, Logs, Metrics, Traces, OpenTelemetry)
\end{enumerate}

\subsubsection{Literature}

\begin{itemize}
    \item BODNER, Jon. Learning Go. O’Reilly, 2024.\cite{learning-go}
    \item HARSANYI, Teiva. 100 Go Mistakes and How to Avoid Them. Manning Publications, 2022.\cite{100-go-mistakes}
    \item HOLMES, Joel. Shipping Go. Manning Publications, 2023.\cite{shipping-go}
\end{itemize}

\subsubsection{Teaching methods}

In-person lectures with hands-on exercises and reviewed homework assignments and projects.

\subsubsection{Assessment methods}

Multiple homework assignments (fifty points) and a final project (fifty points), including its defense. Seventy out of the one hundred points are required for a successful completion.

\end{document}

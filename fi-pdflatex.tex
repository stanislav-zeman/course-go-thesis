\documentclass[
  digital,
  color,
  oneside,
  nosansbold,
  nocolorbold,
  lof,
  lot,
]{fithesis4}
\usepackage[resetfonts]{cmap}
\usepackage[T1,T2A]{fontenc}
\usepackage[
  main=english,
  english
]{babel}

\thesissetup{
    date        = \the\year/\the\month/\the\day,
    university  = mu,
    faculty     = fi,
    type        = bc,
    department  = Department of Computer Science,
    author      = Stanislav Zeman,
    gender      = m,
    advisor     = {RNDr. Martin Ukrop, Ph.D.},
    title       = {Designing a Comprehensive Course on Go},
    TeXtitle    = {Designing a Comprehensive Course on Go},
    keywords    = {go, golang, course, lectures, exercises, homework},
    TeXkeywords = {go, golang, course, lectures, exercises, homework},
    abstract    = {
      This thesis deals with designing a new course aimed at teaching the Go programming language. The course is designed to be taught in the academic environment. This work also puts the Faculty of Informatics of Masaryk University into context, and its design reflects some of the shortcomings of local courses.
    },
    thanks      = {
      These are the acknowledgements for my thesis.
    },
    bib         = example.bib,
    facultyLogo = fithesis-fi,
}
\usepackage{makeidx}
\makeindex
\usepackage{paralist}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{url}
\usepackage{markdown}
\usepackage{listings}
\lstset{
  basicstyle      = \ttfamily,
  identifierstyle = \color{black},
  keywordstyle    = \color{blue},
  keywordstyle    = {[2]\color{cyan}},
  keywordstyle    = {[3]\color{olive}},
  stringstyle     = \color{teal},
  commentstyle    = \itshape\color{magenta},
  breaklines      = true,
}
\usepackage{floatrow}
\floatsetup[table]{capposition=top}
\usepackage[babel]{csquotes}

\begin{document}

\chapter{Introduction}

\markright{\textsc{Introduction}}
\addcontentsline{toc}{chapter}{Introduction}

This is the introduction of my thesis.

\chapter{The Go programming language}

\section{Characteristics}

\section{Usage}

\chapter{The current state at FI MUNI}

\section{Lack of up-to-date technologies}

\subsection{Rust}

\section{RedHat Go Course}

\section{Motivation for extending the course}

\subsection{Questionnaire}

\subsection{Interest}

\chapter{The course design}

This chapter gives high-level insight into the course design and the reasoning behind the decisions taken. Detailed explanations about particular lectures, exercises, and homework are given in the fourth chapter.

\section{Elementary information}

The course primarily focuses on teaching the Go programming language. However, its goal is not only to teach the fundamentals of Go, but the course also focuses on equipping its students with the knowledge often required in practice.

The course builds upon the foundations of an already existing Go Course maintained under RedHat\cite{redhat-go-course}. This course already implemented numerous lectures, which were mainly reworked and restructured.

The newly created course is intended to be taught throughout the span of twelve weeks. The first eleven weeks are regular lessons, and the last week is reserved for consultation and/or as a potential substitute class.

\subsection{Licensing}

The original course is open-sourced under the Creative Commons Attribution-ShareAlike (CC BY-SA 4.0 Deed) license, and as it is a share-alike license, the new course had to respect it. There was an option to migrate to the GPLv3 license, which is compatible, but in the end, the CC license was preferred.

The original idea was to keep the new course open-sourced either way, so reusing and adapting the existing course was not a deterrent. The motivation behind this was to keep the course in the public space. Anyone who would like to remix or reuse the course would be free to do so. There is no reason to keep anyone from using any of its materials, even for those with commercial intentions.

\section{Overview}

The course materials are structurally split into three major categories: lectures, exercises, and homework, to be specific, each with a dedicated git repository. All of these categories are inspected in the following subsections. The last subsection of this chapter briefly talks about the final projects.

\subsection{Lectures}

The lecture slides are indubitably the most vital type of material. 

The first six lessons are adaptations of the original RedHat Go Course slides, which underwent major changes and restructuring. The changes were made to make the taught topics more cohesive and easier to follow, as some of the code samples were unnecessarily long or complex. Several lessons, specifically those on REST API and Concurrency, presented outdated principles that warranted updating. Multiple lectures, such as Math \& Go or Python \& Go, were removed altogether as I did not deem them important.

The last five lectures are completely new and extend the course with numerous technologies and third-party libraries. The original course focused solely on using the standard library. Some of the parts of the standard library, notably the HTTP web router, are generally not leveraged in practice. The new lectures focus more on practical usage; therefore, they are not limited in this way.

\subsubsection{Tooling}

I considered multiple tools for creating the lecture slides. It certainly had to be a markdown-oriented technology for multiple reasons. A plain-text solution was a necessity as all materials are versioned using git. This, in turn, eases collaboration with potential open-source contributors, which can further extend the course or fix any existing mistakes.

The original RedHat Go course used the Go Present tool. This solution, created by the Go team, implements an exceptional feature: it can run the Go code in your slides and immediately present the output. For this reason, I decided to continue using it for the new lectures as any other markdown-styled solution did not offer any similar viable alternative.

I also considered Marp as the runner-up. This tool is used throughout the Rust course previously mentioned in the second chapter. Compared to the Go Present tool, the main benefits include much better formatting capabilities, the possibility of exporting slides to multiple data formats like PDF or HTML, and a more straightforward syntax.

\subsection{Exercises}

The exercises are designed to be complementary assignments to lectures. The general feedback on the first course run, as discussed in the second chapter, was a lack of hands-on experience. These exercises were designed to compensate for that. They are, by no means, an equivalent substitute for traditional standard seminars. The students are expected to spend only up to thirty minutes solving them.

Each lecture is paired with a single exercise that can, in some cases, be split into up to two tasks. Both of these, in some way, relate to the topics covered in the lecture.

The exercises are not intended to be reviewed or evaluated in any way. However, they can provide useful on-site insight into the student's understanding of the covered topic, which can be reflected later. These exercises should also serve as the ground for answering potential follow-up questions.

\subsection{Homework}

The homework exercises are a form of individual work. Their goal is to prepare students for their final projects. The homework tasks depend on each other and demonstrate building an application from the ground up.

Starting from the third week, the assignments are published with a fourteen-day deadline followed by a seven-day review period. The review period is designed to give students feedback that they will later incorporate into their solutions.

Contrary to lecture exercises, homework exercises are intended to be reviewed and graded. In the end, they should make up half of the final grade.

\subsection{Projects}

The projects are the final part of the course and make up the second half of the final grade. The projects are estimated to take fifty to sixty hours for each student. The size of the projects should approximately match that estimation.

As part of a bonus lecture \ref{lecture-projects}, the students are presented with a set of technologies or libraries they can leverage in their project implementations. This lecture subordinately serves as a form of motivation.

The general incentive is to make students come up with their own projects. Therefore, no "official" project assignments will be published. This was deeply considered as it may demotivate some students in the final part of the semester. However, I believe that the exploratory bonus lecture is sufficient for driving the students' projects even without predefined assignments.

No matter the choice of project, all of them are finished with a short defense during the examination period. These defenses can be organized either physically or online. Students are expected to give a short presentation and a demonstration. Students should also cover used technologies and libraries and briefly describe their experiences and struggles.

There are multiple means of completing the project, each offering a different set of advantages and disadvantages. The course is designed not to be overly restrictive, therefore giving flexibility of choice for the projects.

The project assignment can be fulfilled in three ways:
\begin{itemize}
 \item Implementing a team project.
 \item Implementing a solo project.
 \item Creating an open-source contribution.
\end{itemize}

\subsubsection{Team projects}

The team projects required coordination between the team members; therefore, it simulates practical collaboration the most. However, it restricts students as they have to agree on a single project assignment. 

The recommended number of team members is up to four students. The size of the projects should be linearly scaled with the number of team members. It is strongly advised not to be exceeded. Any higher number may negatively affect the teams' performance as it brings an additional overhead.

When evaluating projects, it should be verified that the work was roughly evenly distributed between the students. As often happens, some students leave most of the work for their team members and only join in on minor tasks, if at all. Such lack of activity should be reflected in the student's evaluation.

It should also be noted that sometimes, a student implements most of the project assignment independently without giving the rest of the team a chance to contribute appropriately. Differentiation between the two cases is merely impossible. The only way is to consult the team members directly, and even then, the active students tend not to report on and abandon their peers.

\subsubsection{Solo projects}

The solo projects give the most flexibility. Students can implement their own assignments without consulting or cooperating with other team members. This, for example, allows them to implement a project they have long thought about but did not find enough time for its realization.

On the other hand, the lack of interaction with peers is also the biggest disadvantage. The goal of these projects should, at least to some extent, be to get students familiar with real-life software project collaboration. Such projects are hardly implemented by solo developers.

Students generally perceive this way as the path of least resistance, so it should be expected that the majority of projects will be of this kind.

\subsubsection{Open-source contributions}

The open-source contributions are rather experimental. The main motivation behind this variant is to allow students to get involved in the open-source community, give them a guiding hand, and provide feedback for their first steps. 

This path presents several challenges to the students. First, the students must find open-source projects to contribute to. Secondly, they must engage, review current issues, and participate in the discussion and codebase. Lastly, they must implement the changes and get them reviewed and merged.

The pull or merge requests do not have to be merged at the time of the defense, as the tutors cannot guarantee the maintainers' activity. This can be tackled by providing projects maintained by tutors or their colleagues. However, such appropriate "good-first" projects that are simultaneously maintained by the tutors often hardly exist.

The contributions can be split up into multiple pull or merge requests, even to different projects. Therefore, opening a larger pull request and opening multiple smaller ones are both acceptable variants.

The size expectations for the open-source contributions are much lower than those for its project alternatives. Upon its evaluation, the process of searching for an open-source project to contribute to and further involvement in the codebase is considered.

It should be noted that contributing to projects with low activity or without active maintainers should be avoided.

In my opinion, our faculty does not promote open-source collaboration enough. The faculty's lack of permanent open-source-oriented courses exploring open-source workflow and etiquette can further support this statement. It is worth noting that some efforts to introduce such courses have been made in collaboration with industrial partners in the past few years.

\section{Limitations}

\subsection{Covered Topics}

This subsection describes some possible inefficiencies that were later perceived but not incorporated into the course because of the lack of time or space.

\subsubsection{Auth}

The course does not cover authorization or authentication in any way. It is up to debate if the course should cover this topic and, if so, to what extent. I believe that education in this regard, especially with practical application, is insufficient at our faculty. A dedicated course tackling topics like JWT, Cookies, and OAuth2 and their usage should exist instead.

\subsubsection{APIs}

The course currently covers designing and implementing REST APIs. This is still the standard for most service communication. However, during the past decade, multiple other approaches emerged that are often incorporated into systems in practice, notably gRPC and GraphQL. \\

gRPC is an implementation of the Remote Procedure Call (RPC) protocol by Google (g). It is often used for server-to-server communication as it provides type safety, lowers latency thanks to transmitting binary data using its custom format, and performs client/server code generation. \\

GraphQL (GQL) is a query language that was created at Facebook. It is built on top of standard REST API. GQL is often used for APIs that operate with complicated structured data. It removes the necessity to implement numerous endpoints and instead allows GQL queries to be sent to a single endpoint that parses the query and responds only to data specified in the query. Clients can fetch all required data using a single request. This way, the process saves time and network bandwidth.

\subsubsection{DevOps/Ops overlap}

Some of the lectures, namely Infrastructure and Observability, overlap with the DevOps/Ops field. Although the lectures provide Go examples and try to apply the general knowledge to Go, these topics are not Go specific and could be extracted to an additional course in the future. This would free up space for other topics, such as those previously mentioned.

\section{Catalog specification}

This chapter specifies the common catalog criteria used at the Masaryk University.

\subsection{Extent and Intensity}

The following expression notes the intensity of lectures, seminars, and homework, plus the type of completion, respectively.

(2/0/1) + 1 (colloquium)

\subsection{Prerequisities}

No hard requirements are enforced. However, students are expected to have a basic understanding of networking and virtualization.

\subsection{Enrolment limitations}

The course is intended to be run with up to 20 students. It can later be scaled to a higher number, but currently, the intent is to test the new course in practice and interact more with students, which does not scale well and would require opening a second seminar.

\subsection{Course objectives}

Students will understand the fundamentals of the Go programming language and its common uses in practice. They will acquire the required knowledge for entry-level Go developer positions while writing idiomatic Go code, and they will be capable of applying this knowledge to real-life projects.

\subsection{Learning outcomes}

Students will be able to:
\begin{itemize}
    \item Write idiomatic Go code.
    \item Understand the Go concurrency model.
    \item Inspect and optimize Go applications.
    \item Develop REST API services.
    \item Containerize and deploy their applications.
    \item Implement persistence leveraging SQL databases.
    \item Instrument applications with various types of telemetry.
\end{itemize}

\subsection{Syllabus}

\begin{enumerate}
    \item Introduction
    \begin{itemize}
        \item Introduction to Go
        \item IDEs and editors
        \item Installing Go
        \item Running Go
    \end{itemize}
    \item Fundamentals \#1
    \begin{itemize}
        \item Packages \& Visibility
        \item Variables
        \item Data types
        \item Control flow
        \item Functions
        \item Pointers
        \item Structures
    \end{itemize}
    \item Fundamentals \#2
    \begin{itemize}
        \item Interfaces
        \item Errors
        \item Arrays
        \item Slices
        \item Maps
        \item Range
    \end{itemize}
    \item Concurrency \& parallelism
    \begin{itemize}
        \item Goroutines
        \item Runtime
        \item Channels
        \item Select
        \item Related packages
    \end{itemize}
    \item Advanced \#1
    \begin{itemize}
        \item Generics
        \item Packages
        \item Testing
    \end{itemize}
    \item Advanced \#2
    \begin{itemize}
        \item Benchmarks
        \item Optimizations
        \item CGo
        \item Unsafe \& Reflect
    \end{itemize}
    \item REST APIs
    \begin{itemize}
        \item JSON
        \item HTTP
        \item REST API
        \item HTTP package
        \item Routers \& Web frameworks
        \item OpenAPI
        \item Templating
    \end{itemize}
    \item Containers
    \begin{itemize}
        \item Containerization
        \item Docker
        \item Kubernetes
    \end{itemize}
    \item Databases
    \begin{itemize}
        \item SQL
        \item RDBMSs
        \item Migrations
        \item sql
        \item sqlx
        \item sqlc
        \item GORM
    \end{itemize}
    \item Infrastructure
    \begin{itemize}
        \item CI/CD
        \item Infrastructure
        \item GCP
    \end{itemize}
    \item Observability
    \begin{itemize}
        \item Health
        \item Logs
        \item Metrics
        \item Tracing
        \item OpenTelemetry
    \end{itemize}
\end{enumerate}

\subsection{Literature}

\begin{itemize}
    \item O'Reilly: Learning Go \cite{oreilly-learning-go}
\end{itemize}

\subsection{Teaching methods}

In-person lectures with hands-on exercises and reviewed homework assignments.

\subsection{Assessment methods}

Multiple homework assignments (fifty points) and a final project (fifty points), including its defense. Seventy out of the one hundred points are required for a successful completion.

\chapter{The course content}

The content is described in the same order as it is presented to students throughout the semester.

\section{Lecture 00: The course}

This lecture is designed solely to provide elementary information about the course, such as its requirements and outline.

\section{Lecture 01: Introduction}

\subsubsection{Outline}

\begin{itemize}
    \item Introduction to Go
    \begin{itemize}
        \item Origins
        \item Key characteristics \& comparisons
        \item Motivation
    \end{itemize}
    \item IDEs \& editors
    \item Installing Go
    \item Go
    \begin{itemize}
        \item Go executable
        \item Modules
        \item Packages
        \item Hello world
    \end{itemize}
\end{itemize}

\subsubsection{Sections}

\subsection{Exercise 01}

\section{Lecture 02: Fundamentals \#1}

\subsubsection{Outline}

\begin{itemize}
    \item Types
    \item Variables
    \item Control flow
    \item Functions
    \item User-defined data types
    \item Pointers
\end{itemize}

\subsubsection{Sections}

\subsection{Exercise 02}

\section{Lecture 03: Fundamentals \#2}

\subsubsection{Outline}

\begin{itemize}
    \item Interfaces
    \item Errors
    \item Arrays
    \item Slices
    \item Maps
    \item Range
\end{itemize}

\subsubsection{Sections}

\subsection{Exercise 03}

\section{Lecture 04: Concurrency \& Parallelism}

\subsubsection{Outline}

\begin{itemize}
    \item Goroutines
    \item Runtime
    \item Channels
    \item Select
    \item Packages
\end{itemize}

\subsubsection{Sections}

\subsection{Exercise 04}

\section{Lecture 05: Advanced \#1}

\subsubsection{Outline}

\begin{itemize}
    \item Generics
    \item Packages
    \item Testing
\end{itemize}

\subsubsection{Sections}

\subsection{Exercise 05}

\section{Homework 01}

\section{Lecture 06: Advanced \#2}

\subsubsection{Outline}

\begin{itemize}
    \item Benchmarks
    \item Profiling
    \item Optimizations
    \begin{itemize}
        \item References \& Values
        \item Maps
        \item Slices
        \item Loops
        \item Strings
    \end{itemize}
    \item CGo
    \item Unsafe
    \item Reflection
\end{itemize}

\subsubsection{Sections}

\subsection{Exercise 06}

\section{Lecture 07: REST APIs}

\subsubsection{Outline}

\begin{itemize}
    \item JSON
    \item HTTP
    \item REST API
    \item Go \& HTTP
    \begin{itemize}
        \item Standard library
        \item Third-party libraries
        \item Testing webservers
    \end{itemize}
    \item OpenAPI
    \item Templating
\end{itemize}

\subsubsection{Sections}

\subsection{Exercise 07}

\section{Homework 02}

\section{Lecture 08}

\subsubsection{Outline}

\begin{itemize}
    \item Containers
    \item Docker
    \begin{itemize}
        \item Desktop
        \item Hub
        \item Build
        \item Compose
    \end{itemize}
    \item Podman
    \item Testcontainers
    \item Kubernetes
\end{itemize}

\subsubsection{Sections}

\subsection{Exercise 08: Containers}

\section{Lecture 09: Databases}

\subsubsection{Outline}

\begin{itemize}
    \item SQL
    \item RDBMSs
    \item Database migrations
    \item Go \& SQL
    \begin{itemize}
        \item sql
        \item sqlx
        \item sqlc
        \item GORM
    \end{itemize}
\end{itemize}

\subsubsection{Sections}

\subsection{Exercise 09}

\section{Homework 03}

\section{Lecture 10: Infrastructure}

The motivation behind this lecture is to give students an insight into the CI/CD process and how this practice can be applied in the context of Go projects. The second goal is to give students a basic knowledge of how such projects can be deployed and maintained.

The students are expected to understand basic software engineering practices and elementary networking.

\subsubsection{Outline}

\begin{itemize}
    \item Linters
    \item CI/CD
    \begin{itemize}
        \item GitLab CI/CD
        \item GitHub Actions
    \end{itemize}
    \item Infrastructure
    \item Cloud
    \begin{itemize}
        \item GCP
    \end{itemize}
\end{itemize}

\subsubsection{Sections}

The first section covers linters and expands on the knowledge acquired in the introductory lesson, where the built-in go-vet linter was introduced. Most of this section is dedicated to the golangci-lint tool, a linter aggregator incorporated in many projects and is the most complex tool today. Together with formatters, these tools are necessary in the continuous integration process introduced in the following section.

The second section introduces the CI/CD process. The primary goal of this section is to provide students with the knowledge to implement the CI/CD pipeline using both GitLab CI/CD and GitHub Actions.

As the faculty operates a self-hosted GitLab instance, almost all of the git-related work is done using GitLab. Consequently, most students do not interact with GitHub throughout their studies. The secondary goal of this chapter is to familiarize students with GitHub so they can join the open-source community, as most open-source software is developed on the GitHub platform.

The third section gives an introduction to infrastructure design. Introduces basic concepts such as proxying, load balancing, and application scaling. Two related technologies are introduced to leverage these concepts, namely Traefik Proxy and Caddy. This section aims to give students a basic understanding of how to provision basic infrastructure and tackle basic infrastructure design problems such as fault tolerance, scaling, or encryption.

The last section introduces all major cloud providers (Amazon, Microsoft, and Google) and further develops into Google Cloud Platform (GCP). As Google offers free credits thanks to the faculty program, it is a great opportunity for students to get their hands on operating cloud infrastructure. A set of basic services that GCP offers are introduced so students can leverage these in their follow-up projects.

\subsection{Exercise 10}

The exercise comprises two tasks. The second task is more of a demo in which the tutor will guide the students through the GCP Console.

As students generally have a basic understanding of CI, thanks to their previous experiences, it is not practiced at the seminar. Instead, the seminar time is given to the GCP. The goal of the demo/exercise is to get students familiar with the GCP so they can provision their own infrastructure.

Tasks:
\begin{itemize}
    \item The first task involves setting up a Caddy server instance as a reverse proxy/load balancing multiple ping-pong service instances.
    \item The second task involves setting up an automatic build and deployment using Cloud Run, provisioning a Compute Engine virtual machine and a Cloud SQL SQL server that can later be used for the student's projects.
\end{itemize}
    
\section{Lecture 11: Observability}

\subsubsection{Outline}

\begin{itemize}
    \item Health
    \item Metrics
    \begin{itemize}
        \item Prometheus
        \item Grafana
    \end{itemize}
    \item Logs
    \begin{itemize}
        \item Loggers
        \item Loki
    \end{itemize}
    \item Traces
    \begin{itemize}
        \item Jaeger
    \end{itemize}
    \item OpenTelemetry
\end{itemize}

\subsubsection{Sections}

\subsection{Exercise 11}

\section{Homework 04}

\section{Bonus Lecture: Projects} \label{lecture-projects}

The motivation for this lecture is to provide students with an overview of state-of-the-art libraries. The technologies are split up into multiple sections depending on their use case.

\subsubsection{Outline}

\begin{itemize}
    \item CLI
    \item TUI
    \item Desktop
    \item Web
    \item Open-source
\end{itemize}

\subsubsection{Content}

The Command Line Interface (CLI) section provides basic information about the most frequently used libraries to implement command-line applications. These libraries include the Cobra \cite{spf13-cobra} and the CLI \cite{urfave-cli}.

The lecture continues by introducing the Bubbletea \cite{charmbracelet-bubbletea} framework and its ecosystem for creating Terminal User Interface (TUI) applications.

The third section introduces possible libraries for implementing desktop applications. The first framework it introduces is Wails \cite{wailsapp-wails}, an alternative to JavaScript Electron \cite{electron-electron}, or Rust Tauri \cite{tauri-apps-tauri} frameworks. The second mentioned library is Fyne \cite{fyne-io-fyne}, which, also from desktop environments, supports the iOS and Android mobile platforms.

The web sections mentions the possibility of creating a web application with a combination of Go backend and an optional frontend technology. The HTMX HTML extension \cite{bigskysoftware-htmx} is mentioned as an alternative to traditional single-page applications (SPAs).

The lecture ends with giving multiple links to resources related to open-source development or possible Go projects.

\chapter{Conclusion}

\printbibliography[heading=bibintoc]

\appendix
\chapter{Course materials}

All course materials are maintained under the \href{https://github.com/course-go}{course-go} GitHub organization. To preserve the current state of the materials, all relevant repositories were exported and compressed into an attachment to this thesis. Each top-level directory in the attached archive maps to a GitHub repository. The directories contain versions of materials that existed when submitting this thesis and are most likely out-of-date as you read this text. Inspect the respective GitHub repositories if you want to view the updated version.

The GitHub repositories for respective directories can be found under the following URLs:
\begin{itemize}
    \item \href{https://github.com/course-go/lectures}{lectures}
    \item \href{https://github.com/course-go/exercises}{exercises}
    \item \href{https://github.com/course-go/homework}{homework}
    \item \href{https://github.com/course-go/code}{code}
    \item \href{https://github.com/course-go/course}{course}
    \item \href{https://github.com/course-go/ping-pong}{ping-pong}
\end{itemize}

\section{lectures}

The lectures directory contains all slides and their respective assets (images, code samples, videos, etc.). The supplied README in the directory guides you on how to run the slides.

\section{exercises}

The exercises directory contains all exercises with assignments and related code. Each exercise is in a separate directory containing a README specifying the assignment.

\section{homework}

The homework directory contains all homework assignments. Each homework assignment is located in its respective directory. The assignments are given in the form of a README.

\section{code}

The code directory contains source code that either implements solutions to some of the exercises or implements some form of functionality used throughout the exercises.
\section{course}

The course directory contains information that serves as the starting point when people want to learn more about the course.
\section{ping-pong}

The ping-pong directory contains a simple REST API project used for teaching deployments and their automation. It is split up from the code project as it simplifies the deployments.

\end{document}
